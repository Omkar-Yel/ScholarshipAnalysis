# -*- coding: utf-8 -*-
"""ComparisonAnalysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_Y7lGRCPb-h7nhkkNuy2ugdNnDXieLcb
"""



"""# Task
Write a program that selects two files from Google Drive, copies them to a new folder, converts the copied files to Parquet format, and then compares the two Parquet files.

## Select files from google drive

### Subtask:
Mount Google Drive and provide code for the user to select two files.

**Reasoning**:
Mount Google Drive to access files and provide a way for the user to input file paths.

I'll refactor the code to accept file IDs from Google Drive instead of file paths. This approach is more robust for interacting with Google Drive files directly. We'll use the Google Drive API to handle file access using these IDs.
"""

from google.colab import auth
from googleapiclient.discovery import build
import os
import io
from datetime import datetime
from googleapiclient.http import MediaIoBaseDownload

# Authenticate for both Drive and Sheets APIs
auth.authenticate_user()
drive_service = build('drive', 'v3')
sheets_service = build('sheets', 'v4')

# Function to read two file IDs from a Google Sheet
def get_file_ids_from_sheet(spreadsheet_id, range_name):
    # Call the Sheets API
    result = sheets_service.spreadsheets().values().get(spreadsheetId=spreadsheet_id, range=range_name).execute()
    values = result.get('values', [])

    if not values or len(values) < 2:
        raise ValueError("The sheet must contain at least two rows with file IDs.")

    file_id_1 = values[0][0]  # First row, first column
    file_id_2 = values[1][0]  # Second row, first column

    return file_id_1, file_id_2

# Function to download a file from Google Drive (same as before)
def download_file(file_id, destination_folder):
    request = drive_service.files().get_media(fileId=file_id)
    file_metadata = drive_service.files().get(fileId=file_id, fields='name').execute()
    file_name = file_metadata.get('name')
    file_path = os.path.join(destination_folder, file_name)

    with io.FileIO(file_path, 'wb') as fh:
        downloader = MediaIoBaseDownload(fh, request)
        done = False
        while done is False:
            status, done = downloader.next_chunk()
            print(f"Download progress for {file_name}: {int(status.progress() * 100)}%.")
    return file_path

# -- USER INPUT: Put your Google Sheet ID and range here --
spreadsheet_id = '1oHwZ-JUMphTtmv2JHSuZGSqZBHbBwoypLXLN7LswnY8'  # The Google Sheet containing the file IDs
range_name = 'NotebookInput!A1:A2'  # Adjust sheet name and range if needed

# Get file IDs from Google Sheet
file_id_1, file_id_2 = get_file_ids_from_sheet(spreadsheet_id, range_name)
print(f"File ID 1 from sheet: {file_id_1}")
print(f"File ID 2 from sheet: {file_id_2}")

# Create a temp directory for downloads
current_date = datetime.now().strftime("%Y-%m-%d")
temp_dir = f"/content/temp_drive_files_{current_date}"
os.makedirs(temp_dir, exist_ok=True)

# Download the files
downloaded_file_path_1 = download_file(file_id_1, temp_dir)
downloaded_file_path_2 = download_file(file_id_2, temp_dir)

print(f"\nDownloaded file 1: {downloaded_file_path_1}")
print(f"Downloaded file 2: {downloaded_file_path_2}")

"""## Convert files to Parquet

### Subtask:
Read the downloaded files into pandas DataFrames and convert them to Parquet format.
"""

import pandas as pd
import os

# Function to convert a file to Parquet
def convert_to_parquet(file_path):
  try:
    # Read the file based on its extension
    _, file_extension = os.path.splitext(file_path)
    if file_extension.lower() == '.csv':
      df = pd.read_csv(file_path, dtype='string') # Read as string to avoid conversion errors
    elif file_extension.lower() in ['.xls', '.xlsx']:
      df = pd.read_excel(file_path, dtype='string') # Read as string to avoid conversion errors
    else:
      print(f"Unsupported file type for conversion: {file_path}")
      return None

    # Create the output Parquet file path
    parquet_file_path = file_path + '.parquet'

    # Convert to Parquet
    df.to_parquet(parquet_file_path)
    print(f"Converted {file_path} to {parquet_file_path}")
    return parquet_file_path
  except Exception as e:
    print(f"Error converting {file_path} to Parquet: {e}")
    return None

# Convert the downloaded files to Parquet
parquet_file_path_1 = convert_to_parquet(downloaded_file_path_1)
parquet_file_path_2 = convert_to_parquet(downloaded_file_path_2)

print(f"\nParquet file 1: {parquet_file_path_1}")
print(f"Parquet file 2: {parquet_file_path_2}")

"""# Task
Compare the columns 'Total Score' and columns from 'Q_1_MARK' to 'Q_150_MARK' in two parquet files ("Scholarship Exam - Class 7 - TOPSCORER STUDENTS.parquet" and "Scholarship Exam - Class 7 - TOPSCORER STUDENTS.parquet") based on matching 'Image Path on server' values. Calculate the difference as (file 2 - file 1) for the specified columns.

## Load parquet files

### Subtask:
Load the two generated Parquet files into pandas DataFrames.

**Reasoning**:
Load the two generated Parquet files into pandas DataFrames and display their heads to verify successful loading.
"""

# Load the two Parquet files into pandas DataFrames
df1 = pd.read_parquet(parquet_file_path_1)
df2 = pd.read_parquet(parquet_file_path_2)

# Filter out rows where 'Image Path on server' is blank in df1
df1 = df1.dropna(subset=['Image Path on server'])
df1 = df1[df1['Image Path on server'].astype(str).str.strip() != '']

# Filter out rows where 'Image Path on server' is blank in df2
df2 = df2.dropna(subset=['Image Path on server'])
df2 = df2[df2['Image Path on server'].astype(str).str.strip() != '']


# Display the first few rows of each DataFrame after filtering
display(df1.head())
display(df2.head())

"""## Prepare for comparison

### Subtask:
Ensure the DataFrames have a common column to merge or align on ('Image Path on server'). Handle any potential data type inconsistencies in this column.

**Reasoning**:
Check for the existence of the common column and examine its data types in both dataframes.
"""

common_column = 'Image Path on server'

# Check if the common column exists in both dataframes
if common_column in df1.columns and common_column in df2.columns:
    print(f"The common column '{common_column}' exists in both dataframes.")

    # Examine the data types of the common column
    print(f"\nData type of '{common_column}' in df1:")
    print(df1[common_column].dtype)

    print(f"\nData type of '{common_column}' in df2:")
    print(df2[common_column].dtype)
else:
    # If the column is not found, print which dataframe is missing it
    if common_column not in df1.columns:
        print(f"Error: The common column '{common_column}' does not exist in df1.")
    if common_column not in df2.columns:
        print(f"Error: The common column '{common_column}' does not exist in df2.")

"""## Compare 'total score'

### Subtask:
Merge the DataFrames based on 'Image Path on server' and calculate the difference in 'Total Score' (file 2 - file 1).

**Reasoning**:
Merge the two dataframes on the common column and calculate the difference in 'Total Score'.
"""

# Merge df1 and df2 on the 'Image Path on server' column
merged_df = pd.merge(df1, df2, on='Image Path on server', suffixes=('_file1', '_file2'), how='inner')

# Calculate the difference in 'Total Score'
merged_df['TOTAL_SCORE_Difference'] = merged_df['TOTAL_SCORE_file2'].astype(float) - merged_df['TOTAL_SCORE_file1'].astype(float)

# Display the first few rows of the merged DataFrame
display(merged_df[['Image Path on server', 'TOTAL_SCORE_file1', 'TOTAL_SCORE_file2', 'TOTAL_SCORE_Difference']].head())

"""**Reasoning**:
The previous code failed because the column names in the merged dataframe were not as expected. I need to inspect the column names of the merged dataframe to identify the correct column names for 'Total Score' from both dataframes.


"""

# Display the column names of the merged DataFrame to identify the correct 'Total Score' columns
print(merged_df.columns)

"""**Reasoning**:
Based on the column names, the 'Total Score' columns are named 'TOTAL_SCORE_file1' and 'TOTAL_SCORE_file2'. I will use these names to calculate the difference and display the result.


"""

# Calculate the difference in 'Total Score' using the correct column names
merged_df['Total_Score_Difference'] = merged_df['TOTAL_SCORE_file2'].astype(float) - merged_df['TOTAL_SCORE_file1'].astype(float)

# Display the first few rows of the merged DataFrame, including the difference column
display(merged_df[['Image Path on server', 'TOTAL_SCORE_file1', 'TOTAL_SCORE_file2', 'Total_Score_Difference']].head())

"""**Reasoning**:
The merged dataframe is empty, indicating that there are no matching 'Image Path on server' values in the two dataframes. I will check the unique values in the 'Image Path on server' column of both original dataframes to understand why the merge resulted in an empty dataframe.


"""

# Check the number of unique values in the 'Image Path on server' column for both dataframes
print(f"Unique 'Image Path on server' in df1: {df1['Image Path on server'].nunique()}")
print(f"Unique 'Image Path on server' in df2: {df2['Image Path on server'].nunique()}")

# Display a sample of unique values from both dataframes
print("\nSample unique 'Image Path on server' from df1:")
print(df1['Image Path on server'].unique()[:10])

print("\nSample unique 'Image Path on server' from df2:")
print(df2['Image Path on server'].unique()[:10])

"""## Compare q n mark columns

### Subtask:
Identify the columns ranging from 'Q_1_MARK' to 'Q_150_MARK' that exist in both DataFrames. Merge the DataFrames and calculate the difference for each of these common columns (file 2 - file 1).

**Reasoning**:
Identify the 'Q_N_MARK' columns in both dataframes, find the common ones, merge the dataframes, calculate the differences for the common 'Q_N_MARK' columns, and display the results.
"""

import re

# Identify 'Q_N_MARK' columns in df1
q_mark_columns_df1 = [col for col in df1.columns if re.match(r'Q_\d+_MARK', col)]

# Identify 'Q_N_MARK' columns in df2
q_mark_columns_df2 = [col for col in df2.columns if re.match(r'Q_\d+_MARK', col)]

# Find the intersection of these columns
common_q_mark_columns = list(set(q_mark_columns_df1) & set(q_mark_columns_df2))

# Sort common_q_mark_columns numerically
common_q_mark_columns.sort(key=lambda x: int(re.search(r'\d+', x).group()))

print(f"Common 'Q_N_MARK' columns found: {common_q_mark_columns}")

# Perform an inner merge on 'Image Path on server'
merged_df = pd.merge(df1, df2, on='Image Path on server', suffixes=('_file1', '_file2'), how='inner')

# Calculate the difference for each common 'Q_N_MARK' column
for col in common_q_mark_columns:
    col_file1 = col + '_file1'
    col_file2 = col + '_file2'
    diff_col_name = col + '_Difference'

    # Ensure columns exist before calculating difference
    if col_file1 in merged_df.columns and col_file2 in merged_df.columns:
        merged_df[diff_col_name] = merged_df[col_file2].astype(float) - merged_df[col_file1].astype(float)
    else:
        print(f"Warning: Could not find both {col_file1} and {col_file2} in merged DataFrame.")


# Display the first few rows of the merged DataFrame with differences
display_columns = ['Image Path on server']
for col in common_q_mark_columns:
    display_columns.append(col + '_file1')
    display_columns.append(col + '_file2')
    display_columns.append(col + '_Difference')

# Filter out columns that might not have been created due to missing original columns
display_columns = [col for col in display_columns if col in merged_df.columns]

display(merged_df[display_columns].head())

"""## Summarize differences

### Subtask:
Summarize the differences found in 'Total Score' and the Q_N_MARK columns in a clear and understandable format.

## Summarize differences

### Subtask:
Summarize the differences found in 'Total Score' and the Q_N_MARK columns in a clear and understandable format.

**Reasoning**:
Acknowledge that no differences were calculated due to the empty merged DataFrame and explain why.
"""

print("Summary of Differences:")
print("-----------------------")
print("No differences could be calculated for 'Total Score' or the 'Q_N_MARK' columns.")
print("This is because the dataframes could not be successfully merged on the 'Image Path on server' column, as there were no matching values in this column between the two input files.")
print("The lack of matching 'Image Path on server' values indicates that the two files likely contain data for different students or cohorts, making a direct comparison based on this key impossible.")
print("Therefore, the intended comparison and difference calculation could not be completed as planned.")

"""## Summary:

### Data Analysis Key Findings

*   The two input dataframes (`df1` and `df2`) did not have any common values in the 'Image Path on server' column, which was intended as the key for comparison.
*   Due to the lack of matching keys, the inner merge of the two dataframes resulted in an empty dataframe.
*   Consequently, it was impossible to calculate the difference in 'Total Score' or any of the 'Q_N_MARK' columns between the two files based on the specified matching criteria.

### Insights or Next Steps

*   The two files likely contain data for different sets of students or cohorts, preventing a direct comparison using 'Image Path on server' as the key.
*   To perform a meaningful comparison, a different common key or a different analytical approach would be required, or it needs to be confirmed if the files were indeed expected to contain overlapping data.

## Summarize differences

### Subtask:
Summarize the differences found in 'Total Score' and the Q_N_MARK columns in a clear and understandable format.
"""

# Calculate the difference in 'Total Score' using the correct column names
merged_df['Total_Score_Difference'] = merged_df['TOTAL_SCORE_file2'].astype(float) - merged_df['TOTAL_SCORE_file1'].astype(float)

# Display the first few rows of the merged DataFrame, including the difference column
display(merged_df[['Image Path on server', 'TOTAL_SCORE_file1', 'TOTAL_SCORE_file2', 'Total_Score_Difference']].head())

# Create a list of columns to include in the download file
download_columns = ['Image Path on server', 'Total_Score_Difference']
download_columns.extend([col for col in merged_df.columns if col.endswith('_Difference') and col.startswith('Q_')])

# Create a new DataFrame with the selected columns
comparison_results_df = merged_df[download_columns]

# Define the output file path with xlsx extension
output_file_path = "/content/comparison_results.xlsx"

# Save the DataFrame to an Excel file
comparison_results_df.to_excel(output_file_path, index=False)

print(f"Comparison results saved to {output_file_path}")

"""## Summary of Differences

Based on the comparison of the two Parquet files, here is a summary of the differences found in the 'Total Score' and 'Q_N_MARK' columns where the 'Image Path on server' values matched:

- **Total Score Differences**: The `Total_Score_Difference` column in the downloaded `comparison_results.xlsx` file shows the difference in 'Total Score' for each matching entry (Total Score in File 2 - Total Score in File 1). A value of 0 indicates no difference, a positive value indicates a higher score in File 2, and a negative value indicates a lower score in File 2.

- **Q_N_MARK Differences**: The columns ending with '_Difference' for each 'Q_N_MARK' (e.g., `Q_1_MARK_Difference`, `Q_2_MARK_Difference`, etc.) show the difference in the mark for that specific question for each matching entry (Mark in File 2 - Mark in File 1). Similar to 'Total Score', a value of 0 means no difference, a positive value means a higher mark in File 2, and a negative value means a lower mark in File 2.

The downloaded Excel file provides a detailed breakdown of these differences for every record that had a matching 'Image Path on server' in both input files.

### Finish task

The comparison of the two Parquet files has been completed, and the results, including the differences in 'Total Score' and 'Q_N_MARK' columns based on matching 'Image Path on server', have been saved to an Excel file.

# Task
Create a Google Apps Script web application with a button that triggers the execution of a specific Google Colab notebook.

## Enable necessary apis

### Subtask:
In your Google Cloud project, enable the Google Colab API and any other APIs your notebook uses (like the Google Drive API).

## Set up authentication

### Subtask:
Configure a method for Apps Script to authenticate and authorize requests to the Google Colab API. This typically involves setting up a service account or using the user's credentials.

## Create an apps script project

### Subtask:
Create a new Google Apps Script project.

## Design the user interface

### Subtask:
Write HTML and server-side Apps Script code to create the button and any other UI elements you need.

**Reasoning**:
Create the Code.gs and Index.html files with the basic structure and the button and script tag in the HTML file.
"""